#include"functionlist.h"
#include"ColorConsole.h"
#include <random>
#include <functional> // for bind
using namespace consts;


double rn(void)//rn()-random number generated by mt19937 
{
	//MT19937  Mersenne twister very long period up to 2^19937−1 it's about 4,3•10^6001
	//https://www.guyrutenberg.com/2014/05/03/c-mt19937-example/ 
	//https://www.cnblogs.com/egmkang/archive/2012/09/06/2673253.html 
	random_device rd; //random_device is a uniformly-distributed integer random number generator 
	//that produces non-deterministic random numbers.
	//mt19937 rng(rd());
	auto my_rand1 = bind(uniform_real_distribution<double>(0.0, 1.0), mt19937(rd()));
	double r1;
	r1 = my_rand1();
	return(r1);
}
double rn1(void)//same as function rn(), but start with a fixed number
{
	
	static std::mt19937 generator(42);
	static std::uniform_real_distribution<double> dist(0.0, 1.0);

	return dist(generator);
}


// Function to display a colored progress bar with optional update frequency by changing step!
void showProgressBar(int current, int total, int barWidth, int step) {
	if (current % step != 0 && current != total) return;

	float progress = static_cast<float>(current) / total;
	int pos = static_cast<int>(barWidth * progress);

	std::cout << "\r" << CYAN << "[";
	for (int i = 0; i < barWidth; ++i) {
		if (i < pos) std::cout << GREEN << "=";
		else if (i == pos) std::cout << YELLOW << ">";
		else std::cout << " ";
	}
	std::cout << CYAN << "] " << RESET;

	std::cout << std::fixed << std::setprecision(1)
		<< GREEN << (progress * 100.0) << "% " << RESET;

	std::cout << "(Simulating position " << YELLOW << current << RESET
		<< " / " << CYAN << total << RESET << ")";
	std::cout.flush();

	if (current == total) std::cout << std::endl;
}

//Rotation matrix with Euler angles R=Z(alpha)X(beta)Z(gamma)  
matrix Z_sita(double sita)
{
	matrix Zs(3, 3);
	Zs[0][0] = cos(sita);	Zs[0][1] = -sin(sita);	Zs[0][2] = 0.0;
	Zs[1][0] = sin(sita);	Zs[1][1] = cos(sita);	Zs[1][2] = 0.0;
	Zs[2][0] = 0.0;     	Zs[2][1] = 0.0;	        Zs[2][2] = 1.0;

	return Zs;
}
matrix Y_sita(double sita) {
	matrix Ys(3, 3);
	Ys[0][0] = cos(sita);   Ys[0][1] = 0.0;   Ys[0][2] = sin(sita);
	Ys[1][0] = 0.0;         Ys[1][1] = 1.0;   Ys[1][2] = 0.0;
	Ys[2][0] = -sin(sita);  Ys[2][1] = 0.0;   Ys[2][2] = cos(sita);
	return Ys;
}
matrix X_sita(double sita)
{
	matrix Xs(3, 3);
	Xs[0][0] = 1.0;	Xs[0][1] = 0.0;     	Xs[0][2] = 0.0;
	Xs[1][0] = 0.0;	Xs[1][1] = cos(sita);	Xs[1][2] = -sin(sita);
	Xs[2][0] = 0.0;	Xs[2][1] = sin(sita);	Xs[2][2] = cos(sita);

	return Xs;
}
matrix R_abg(double gamma, double beta, double alpha)
{
	matrix Z_gamma = Z_sita(gamma);
	matrix X_beta = X_sita(beta);
	matrix Z_alpha= Z_sita(alpha);

	return Z_alpha * X_beta * Z_gamma;
}

matrix R_abg_T(double s3, double s2, double s1)  //s3-gamma; s2-beta; s1-alpha
{
	matrix Rt(3, 3);
	Rt[0][0] = cos(s1) * cos(s3) - cos(s2) * sin(s1) * sin(s3);
	Rt[0][1] = -cos(s1)*sin(s3)-cos(s2)*cos(s3)*sin(s1);
	Rt[0][2] = sin(s1) * sin(s2);

	Rt[1][0] = cos(s3)*sin(s1)+cos(s1)*cos(s2)*sin(s3);
	Rt[1][1] = cos(s1)*cos(s2)*cos(s3)-sin(s1)*sin(s3);
	Rt[1][2] = -cos(s1)*sin(s2);

	Rt[2][0] = sin(s2)*sin(s3);
	Rt[2][1] = cos(s3)*sin(s2);
	Rt[2][2] = cos(s2);

	return Rt;

}



double maxOf3Num(const double a, const double b, const double c)
{
	double maxN;
	if (a >= b && a >= c) maxN =a;
	else {
		if (b >= a && b >= c)  maxN = b;
		else maxN = c;
	}
	return maxN;

}

/*
======================================================
Multiplicative generator of pseudo-random numbers
uniformly distributed between 0 and 1:
module  2**40,  multiplier  5**17 = 762 939 453 125
(cycle length  2**38 = 274 877 906 944)

M(0) = 1    [or =a1+a2*2^14+a3*2^28]
M(i+1) = mod(M(i)*(5^17), 2^40)
rnd(i+1) = M(i+1) / (2^40)

The generator is extensively used (and was carefully
tested) in the Department of Stochastic Simulation in
Physics of the Novosibirsk Computing Center; see, for
example, the book

"Stochastic  Simulation",
by S.M.Ermakov and G.A.Mikhailov,
Moscow, Nauka, 1982

"C" realization, by S.M.Prigarin (smp@osmf.sscc.ru)
January, 1999
======================================================
Initial values:  1 <= a1 <= 16383,  0 <= a2 <= 16383,
0 <= a3 <= 4095,   a1 must be odd !
Here we set:  a1=1, a2=0, a3=0
*/


// *************************************** RNG

double RNG1(void)
{
	static long a1 = 1, a2 = 0, a3 = 0;                   // initial values 
	const static long b1 = 11973, b2 = 2800, b3 = 2842;
	long c11, c12, c13, c21, c22, c31, d1, d2, d3;

	const double x1 = 1.0 / 4096.0, x2 = x1 / 16384.0, x3 = x2 / 16384.0;

	c11 = b1 * a1;  c12 = b1 * a2;  c13 = b1 * a3;
	c21 = b2 * a1;  c22 = b2 * a2;
	c31 = b3 * a1;
	d1 = c11;
	d2 = c21 + c12 + (d1 >> 14);
	d3 = c31 + c22 + c13 + (d2 >> 14);
	a1 = d1 & 16383;  a2 = d2 & 16383;  a3 = d3 & 4095;
	//  a1=d1 % 16384;  a2=d2 % 16384;  a3=d3 % 4096;
	return(a3 * x1 + a2 * x2 + a1 * x3);
}

// 2^40-5^17 
double RNG2(void) //RNG - random number uniformly distributed in [0,1]
{
	static long at1 = 1, at2 = 0, at3 = 0; long d1, d2, d3; double r;
	d1 = 11973 * at1;
	d2 = 2800 * at1 + 11973 * at2 + d1 / 16384;
	d3 = 2842 * at1 + 2800 * at2 + 11973 * at3 + d2 / 16384;
	at1 = d1 % 16384; at2 = d2 % 16384; at3 = d3 % 4096;
	r = at3 * 0.000244140625 + at2 * 1.4901161194e-8 + at1 * 9.0949470178e-13;
	return(r);
}


double RefCoeff1(double N21, double CosI)
{
	double AA, BB, BB2, CC, tmp;
	AA = fabs(CosI);   // abs is for int data type !!!
	CC = 1.0 - AA * AA;
	BB2 = N21 * N21 - 1.0 + AA * AA;
	if (BB2 >= 0.0)
	{
		BB = sqrt(BB2);
		tmp = (AA - BB) * (AA - BB) * (AA * BB * AA * BB + CC * CC) / ((AA + BB) * (AA + BB) * (AA * BB + CC) * (AA * BB + CC));
	}
	else tmp = 1.0;
	return tmp;
}

double RefCoeff2(double N21, double CosI)
{
	double SinI2, SinI, tmp, SinR, CosR, R, I;
	SinI2 = 1.0 - CosI * CosI;// in book C=SinI2
	if (SinI2 > 0) SinI = sqrt(SinI2); else SinI = 0.0;

	if (SinI >= N21) tmp = 1.0;
	else
	{
		SinR = SinI / N21;//R--angel refrection
		CosR = sqrt(1.0 - SinR * SinR);
		if (CosI > 0) I = atan(SinI / CosI);  else I = pi / 2.0;
		R = atan(SinR / CosR);
		if (sin(I + R) != 0)
			tmp = 0.5 * SQR(sin(I - R) / sin(I + R)) *
			(1.0 + SQR(cos(I + R) / cos(I - R)));
		else
			tmp = SQR((N21 - 1.0) / (N21 + 1.0));
	}
	return tmp;
}




